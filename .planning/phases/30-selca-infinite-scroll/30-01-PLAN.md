---
phase: 30-selca-infinite-scroll
plan: 01
type: execute
depends_on: []
files_modified:
  - src/app/api/search/selca/route.ts
  - src/lib/selca-types.ts
  - src/components/ExternalSearch.tsx
  - src/components/UnifiedSearch.tsx
domain: []
---

<objective>
selca.kastden.org 무한 스크롤 페이지네이션 구현 - max_time_id 기반 다음 페이지 로딩

Purpose: ExternalSearch 및 UnifiedSearch selca 탭에서 추가 미디어를 동적으로 로드하여 전체 아카이브 탐색 가능
Output: max_time_id 기반 페이지네이션이 동작하는 selca 검색 API 및 양쪽 클라이언트 연동
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-selca-infinite-scroll/DISCOVERY.md
@src/app/api/search/selca/route.ts
@src/lib/selca-types.ts
@src/lib/parsers/selca.ts
@src/components/ExternalSearch.tsx
@src/components/UnifiedSearch.tsx

**Tech stack available:**
- node-html-parser (HTML 파싱)
- Next.js API Routes (서버사이드 검색)
- fetchHtmlFromSelca 유틸 (Phase 29 리팩토링)

**Established patterns:**
- selca-types.ts로 공통 타입 관리
- fetchHtmlFromSelca 재사용
- SelcaSearchResponse 인터페이스

**Constraining decisions:**
- Phase 29: 공통 타입 파일 분리, fetchHtmlFromSelca export
- Phase 28: Bias.selca_slug 기반 즉시 검색 (타임아웃 제거)

**Issues being addressed:**
- selca 검색이 초기 20개 결과만 표시 (전체 아카이브 탐색 불가)
- hasNextPage가 항상 false로 하드코딩됨

**Discovery 결과:**
- selca.kastden.org는 max_time_id 파라미터로 페이지네이션
- max_time_id = 현재 페이지의 가장 오래된(작은) 미디어 ID
- URL: `/owner/{idolSlug}/?max_time_id={마지막ID}`
- 초기 로드: 약 75개 미디어
- 미디어 ID 추출: /original/{ID}/ 또는 /thumb/{ID}.jpg 패턴
- hasNextPage 감지: 파싱 결과 개수 > 0
</context>

<tasks>

<task type="auto">
  <name>Task 1: SelcaSearchResponse에 nextMaxTimeId 필드 추가</name>
  <files>src/lib/selca-types.ts</files>
  <action>
  SelcaSearchResponse 인터페이스에 nextMaxTimeId 필드 추가:
  ```typescript
  export interface SelcaSearchResponse {
    results: SelcaSearchResult[]
    hasNextPage: boolean
    currentPage: number
    nextMaxTimeId?: string  // 다음 페이지 요청에 사용할 max_time_id
  }
  ```

  JSDoc 주석 업데이트하여 페이지네이션 사용법 명시.
  </action>
  <verify>tsc --noEmit 통과, selca-types.ts에 nextMaxTimeId 필드 존재</verify>
  <done>SelcaSearchResponse 타입에 nextMaxTimeId 필드 추가 완료</done>
</task>

<task type="auto">
  <name>Task 2: selca 검색 API에 max_time_id 페이지네이션 구현</name>
  <files>src/app/api/search/selca/route.ts</files>
  <action>
  1. **max_time_id 파라미터 수신:**
     - searchParams.get('maxTimeId') 추가
     - maxTimeId가 있으면 쿼리 파라미터에 포함

  2. **URL 생성 로직 수정:**
     ```typescript
     const params = new URLSearchParams()
     if (maxTimeId) {
       params.set('max_time_id', maxTimeId)
     }
     const ownerUrl = params.toString()
       ? `${BASE_URL}/owner/${idolSlug}/?${params}`
       : `${BASE_URL}/owner/${idolSlug}/`
     ```

  3. **미디어 ID 추출 함수 작성:**
     ```typescript
     function extractMediaId(href: string): string | null {
       // /original/6753580/... -> "6753580"
       // /thumb/6753580.jpg -> "6753580"
       const originalMatch = href.match(/\/original\/(\d+)\//)
       const thumbMatch = href.match(/\/thumb\/(\d+)\.jpg/)
       return originalMatch?.[1] || thumbMatch?.[1] || null
     }
     ```

  4. **nextMaxTimeId 추적:**
     - 파싱 루프에서 각 미디어 ID 추출
     - 가장 작은(마지막) ID를 nextMaxTimeId로 저장

  5. **hasNextPage 계산:**
     - `const hasNextPage = results.length > 0`
     - 결과가 있으면 다음 페이지 존재

  6. **pageSize 제한 제거:**
     - `const pageSize = 20` 삭제
     - `slice(0, pageSize)` 삭제
     - 파싱된 전체 결과 반환 (selca는 서버에서 약 75개씩 반환)

  7. **응답에 nextMaxTimeId 포함:**
     ```typescript
     const responseData: SelcaSearchResponse = {
       results: paginatedResults,
       hasNextPage,
       currentPage: page,
       nextMaxTimeId: nextMaxTimeId || undefined,
     }
     ```

  **주의사항:**
  - extractMediaId는 null 반환 가능 (미디어 ID 없는 링크 스킵)
  - 파싱 루프에서 mediaId가 있는 경우만 nextMaxTimeId 업데이트
  - 첫 페이지 요청 시 maxTimeId 없음 (초기 로드)
  </action>
  <verify>
  - curl "http://localhost:3000/api/search/selca?query=aespa_winter" → nextMaxTimeId 포함, hasNextPage true
  - curl "http://localhost:3000/api/search/selca?query=aespa_winter&maxTimeId={id}" → 다음 페이지 결과 반환
  - 빈 결과 시 hasNextPage false
  </verify>
  <done>
  - max_time_id 파라미터 처리 구현
  - nextMaxTimeId 추출 및 응답 포함
  - hasNextPage 동적 계산
  - 전체 결과 반환 (pageSize 제한 제거)
  </done>
</task>

<task type="auto">
  <name>Task 3: ExternalSearch에서 max_time_id 기반 페이지네이션 연결</name>
  <files>src/components/ExternalSearch.tsx</files>
  <action>
  1. **searchSelca 함수 수정:**
     - API 응답에서 nextMaxTimeId 추출
     - 상태에 저장: `const [selcaNextMaxTimeId, setSelcaNextMaxTimeId] = useState<string | undefined>()`

  2. **API 요청에 maxTimeId 포함:**
     ```typescript
     const searchSelca = async (searchQuery: string, maxTimeId?: string): Promise<EnrichedResult[]> => {
       const params = new URLSearchParams({ query: searchQuery })
       if (maxTimeId) {
         params.set('maxTimeId', maxTimeId)
       }
       const response = await fetch(`/api/search/selca?${params}`)
       const data = await response.json()

       // Update pagination state
       setSelcaHasNextPage(data.hasNextPage || false)
       setSelcaPage(data.currentPage || 1)
       setSelcaNextMaxTimeId(data.nextMaxTimeId)

       return (data.results as SelcaResult[]).map(...)
     }
     ```

  3. **handleSelcaPageChange 수정:**
     - 페이지 증가 시 selcaNextMaxTimeId 사용
     - 페이지 감소는 미지원 (무한 스크롤 특성상 이전 페이지 불가)
     ```typescript
     const handleSelcaPageChange = async (direction: 'next' | 'prev') => {
       if (direction === 'next' && selcaNextMaxTimeId) {
         const searchResults = await searchSelca(query, selcaNextMaxTimeId)
         setResults(searchResults)
       }
       // prev는 미지원 (버튼 disabled 처리)
     }
     ```

  4. **페이지네이션 UI 수정:**
     - "이전" 버튼 항상 disabled (무한 스크롤 특성)
     - "다음" 버튼은 selcaHasNextPage 기준
     - 페이지 번호 대신 "페이지 {selcaPage}" 표시 (총 페이지 수 없음)

  5. **초기화 로직 업데이트:**
     - 플랫폼 변경/모달 닫기 시 selcaNextMaxTimeId 초기화

  **주의사항:**
  - selca는 단방향 페이지네이션 (다음만 가능, 이전 불가)
  - 첫 페이지 검색 시 maxTimeId 전달 안 함
  - TypeScript 타입: maxTimeId는 string | undefined
  </action>
  <verify>
  - ExternalSearch selca 탭 열기
  - 검색 후 "다음" 버튼 클릭 시 추가 결과 로드
  - "이전" 버튼 항상 disabled
  - 마지막 페이지 도달 시 "다음" 버튼 disabled
  </verify>
  <done>
  - selcaNextMaxTimeId 상태 추가
  - searchSelca에 maxTimeId 파라미터 전달
  - handleSelcaPageChange에서 nextMaxTimeId 사용
  - 페이지네이션 UI 업데이트 (단방향)
  </done>
</task>

<task type="auto">
  <name>Task 4: UnifiedSearch에서 max_time_id 기반 페이지네이션 연결</name>
  <files>src/components/UnifiedSearch.tsx</files>
  <action>
  UnifiedSearch는 캐시 기반 페이지네이션 시스템 사용. nextPageToken(YouTube), nextCursor(Twitter) 패턴과 동일하게 nextMaxTimeId 지원 추가.

  1. **CachedPlatformResult 인터페이스 확장 (87-91줄 근처):**
     ```typescript
     interface CachedPlatformResult {
       // ... 기존 필드
       nextMaxTimeId?: string; // For selca pagination
     }
     ```

  2. **searchSelca 함수 반환 타입 확장 (924-998줄):**
     - 현재: `{ results, hasMore }` 반환
     - 수정: `{ results, hasMore, nextMaxTimeId }` 반환
     ```typescript
     const searchSelca = async (
       searchQuery: string,
       page: number = 1,
       maxTimeId?: string
     ): Promise<{ results: EnrichedResult[]; hasMore: boolean; nextMaxTimeId?: string }> => {
       const params = new URLSearchParams({
         query: queryToUse,
         page: String(page),
         limit: String(API_FETCH_COUNT),
       });
       if (maxTimeId) {
         params.set('maxTimeId', maxTimeId);
       }
       // ... fetch 로직
       return {
         results,
         hasMore: data.hasNextPage ?? false,
         nextMaxTimeId: data.nextMaxTimeId,
       };
     }
     ```

  3. **processPlatformSearch 타입 확장 (1001-1010줄):**
     - searchFn 반환 타입에 nextMaxTimeId 추가 (이미 nextPageToken, nextCursor와 함께 있음)
     ```typescript
     searchFn: () => Promise<{
       results: EnrichedResult[];
       hasMore: boolean;
       nextPageToken?: string;
       nextCursor?: string;
       nextMaxTimeId?: string;  // 추가
     }>,
     ```

  4. **selca 초기 검색 호출 수정 (1245-1252줄):**
     ```typescript
     if (enabledPlatforms.has("selca")) {
       const cachedSelca = cached?.platforms.selca;
       const startPage = cachedSelca?.currentPage ?? 1;
       searchPromises.push(
         processPlatformSearch(
           "selca",
           cachedSelca,
           () => searchSelca(query, startPage, cachedSelca?.nextMaxTimeId),
           newCachedResults
         )
       );
     }
     ```

  5. **캐시 저장 시 nextMaxTimeId 포함:**
     - processPlatformSearch 내부에서 searchFn 결과의 nextMaxTimeId를 캐시에 저장
     - 기존 nextPageToken, nextCursor와 동일한 패턴

  6. **loadMoreForPlatform에 selca 처리 추가 (필요 시):**
     - selca "더 보기" 시 nextMaxTimeId 사용하여 searchSelca 호출
     - 기존 YouTube(nextPageToken), Twitter(nextCursor) 패턴 참조

  **주의사항:**
  - UnifiedSearch는 여러 플랫폼을 동시에 처리하므로 processPlatformSearch 헬퍼 함수 활용
  - 캐시 시스템(searchCache.ts)은 수정 불필요 - 클라이언트 상태만 관리
  - selca는 page 파라미터와 maxTimeId를 모두 전달 (API는 maxTimeId 우선 사용)
  </action>
  <verify>
  - UnifiedSearch에서 selca 플랫폼 활성화 후 검색
  - 결과 표시 후 "더 보기" 클릭 시 추가 결과 로드
  - DevTools Network에서 maxTimeId 파라미터 포함 확인
  - TypeScript 오류 없음
  </verify>
  <done>
  - CachedPlatformResult에 nextMaxTimeId 필드 추가
  - searchSelca에서 nextMaxTimeId 반환
  - processPlatformSearch에서 nextMaxTimeId 처리
  - 캐시에 nextMaxTimeId 저장 및 활용
  - selca "더 보기" 시 max_time_id 기반 페이지네이션 동작
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` 성공
- [ ] tsc --noEmit 통과
- [ ] ExternalSearch: selca 검색 후 "다음" 버튼으로 추가 페이지 로드 확인
- [ ] UnifiedSearch: selca "더 보기" 클릭 시 추가 결과 로드 확인
- [ ] nextMaxTimeId가 응답에 포함되는지 확인 (DevTools Network 탭)
- [ ] 빈 결과 시 hasNextPage false, "다음"/"더 보기" 버튼 disabled 확인
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- selca 검색 페이지네이션이 정상 동작 (max_time_id 기반)
- ExternalSearch에서 "다음" 버튼으로 추가 페이지 로드 가능
- UnifiedSearch에서 "더 보기" 버튼으로 추가 결과 로드 가능
- 마지막 페이지 감지 정확 (hasNextPage false)
</success_criteria>

<output>
After completion, create `.planning/phases/30-selca-infinite-scroll/30-01-SUMMARY.md`:

# Phase 30 Plan 01: Selca Infinite Scroll Summary

**selca.kastden.org 무한 스크롤 페이지네이션 구현 완료 - max_time_id 기반 동적 로딩**

## Accomplishments

- SelcaSearchResponse에 nextMaxTimeId 필드 추가
- selca 검색 API에 max_time_id 파라미터 처리 구현
- extractMediaId 함수로 미디어 ID 추출
- hasNextPage 동적 계산 (결과 개수 기반)
- ExternalSearch에서 max_time_id 기반 페이지네이션 연결
- UnifiedSearch에서 캐시 기반 페이지네이션 연결
- 단방향 페이지네이션 UI (다음만 가능, 이전 불가)

## Files Created/Modified

- `src/lib/selca-types.ts` - nextMaxTimeId 필드 추가
- `src/app/api/search/selca/route.ts` - max_time_id 페이지네이션 구현
- `src/components/ExternalSearch.tsx` - max_time_id 기반 페이지 로딩
- `src/components/UnifiedSearch.tsx` - 캐시 기반 max_time_id 페이지네이션

## Decisions Made

1. **단방향 페이지네이션**: selca는 max_time_id 기반으로 다음 페이지만 가능 (이전 페이지 불가)
2. **pageSize 제거**: selca 서버가 약 75개씩 반환하므로 클라이언트 제한 불필요
3. **미디어 ID 추출**: /original/{ID}/ 및 /thumb/{ID}.jpg 패턴 모두 지원

## Issues Encountered

None

## Next Phase Readiness

- selca 전체 아카이브 탐색 가능
- Phase 30 완료 - 로드맵 완성
</output>
